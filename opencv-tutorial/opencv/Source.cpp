#include <iostream>
#include <opencv2/opencv.hpp>
#include "traffic_sign_detector.h"
#include "pedestrian_detector.h"

using namespace cv;
using namespace std;

// filtering
#if 1
/// Global Variables
int DELAY_CAPTION = 1500;
int DELAY_BLUR = 100;
int MAX_KERNEL_LENGTH = 31;

Mat src; Mat dst;
char window_name[] = "Filter Demo 1";
/// Function headers
int display_caption(char* caption);
int display_dst(int delay);


int foo() {
	namedWindow(window_name, CV_WINDOW_AUTOSIZE);

	/// Load the source image
	src = imread("a.jpg", 1);

	if (display_caption("Original Image") != 0) { return 0; }

	dst = src.clone();
	if (display_dst(DELAY_CAPTION) != 0) { return 0; }


	/// Applying Gaussian blur
	if (display_caption("Gaussian Blur") != 0) { return 0; }

	for (int i = 1; i < MAX_KERNEL_LENGTH; i = i + 2)
	{
		GaussianBlur(src, dst, Size(i, i), 0, 0);
		if (display_dst(DELAY_BLUR) != 0) { return 0; }
	}

	/// Applying Median blur
	if (display_caption("Median Blur") != 0) { return 0; }

	for (int i = 1; i < MAX_KERNEL_LENGTH; i = i + 2)
	{
		medianBlur(src, dst, i);
		if (display_dst(DELAY_BLUR) != 0) { return 0; }
	}

	waitKey(0);
}

int display_caption(char* caption)
{
	dst = Mat::zeros(src.size(), src.type());
	putText(dst, caption,
		Point(src.cols / 4, src.rows / 2),
		CV_FONT_HERSHEY_COMPLEX, 1, Scalar(255, 255, 255));

	imshow(window_name, dst);
	int c = waitKey(DELAY_CAPTION);
	if (c >= 0) { return -1; }
	return 0;
}

int display_dst(int delay)
{
	imshow(window_name, dst);
	int c = waitKey(delay);
	if (c >= 0) { return -1; }
	return 0;
}

#endif
int main(int argc, char** argv)
{
	//backg sub
#if 0
	Mat fgMaskMOG2, frame; //fg mask fg mask generated by MOG2 method
	Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

	pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
	VideoCapture cap("Yol01.avi");
	while (true) {
		cap >> frame;
		pMOG2->apply(frame, fgMaskMOG2);
		imshow("a", fgMaskMOG2);
		waitKey(30);
	}
#else
	Mat road = imread("road2.jpg");
	vector<Rect> r = TrafficSignDetector::GetRedTrafficSigns(road);

	rectangle(road, r.at(0), Scalar(0,255,0), 5 );
	while (true) {
		imshow("winn", road);
		waitKey(30);
	}

	//foo();
	VideoCapture cap("Yol01.avi");
		/*
		CV_LOAD_IMAGE_UNCHANGED (<0)
		CV_LOAD_IMAGE_GRAYSCALE (0)
		CV_LOAD_IMAGE_COLOR (>0)
	*/
	Mat m1 = imread("fid.png");
	//IplImage* img = cvLoadImage("greatwave.png", 1);

	vector<vector<Point> > vContours;
	vector<Vec4i> vHierarchy;
	Mat mEdges;

	Canny(m1, mEdges, 100, 400);
	findContours(mEdges.clone(), vContours, vHierarchy, RETR_TREE, CV_CHAIN_APPROX_SIMPLE);
	
	for (int i = 0; i < vContours.size(); ++i) {
		vector<Point> approx;
		
		approxPolyDP(vContours[i], approx, arcLength(vContours[i], true) * 0.02, true);

		cout << approx.size() << endl;

		if (approx.size() == 4) {
			
			drawContours(m1, vContours, i, Scalar(0, 0, 255), 2);

		}

	}


	Mat E = Mat::eye(4, 4, CV_64F);
	Mat O = Mat::ones(2, 2, CV_32F);
	Mat Z = Mat::zeros(3, 3, CV_8UC1);

	/*PedestrianDetector *detector = new PedestrianDetector();
	Mat p1 = imread("P1.png");
	Mat p2 = imread("P2.png");
	Mat p3 = imread("P3.png");
	vector<Rect> v1 = detector->GetBoundingRectangles(p1);
	vector<Rect> v2 = detector->GetBoundingRectangles(p2);
	vector<Rect> v3 = detector->GetBoundingRectangles(p3);*/
	
	namedWindow("window4", WINDOW_NORMAL);

	while (true) {
		cap >> m1;
		/*rectangle(p1, v1.at(0), Scalar(255, 0, 0), 2);
		rectangle(p2, v2.at(0), Scalar(255, 0, 0), 2);
		rectangle(p3, v3.at(0), Scalar(255, 0, 0), 2);
		imshow("window1", p1);
		imshow("window2", p2);
		imshow("window3", p3);*/
		imshow("window4", m1);
		waitKey(30);
	}

	return 0;
#endif
}